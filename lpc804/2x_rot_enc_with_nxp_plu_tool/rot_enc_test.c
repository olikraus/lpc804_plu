/*

  rot_enc_usart.c

  Configuration is 115200 8-N-1. Only "\n" is sent. Receiving terminal should add \r
  (e.g. use add CR function in "minicom")
  
  Received chars are echoed back enclosed in "<?>" once per second.
  
  Unix: "tail -f /dev/ttyUSB0" should also work.

*/

#include <stddef.h>
#include <LPC8xx.h>
#include <syscon.h>
#include <gpio.h>
#include <swm.h>
#include <uart.h>
#include <delay.h>
#include <util.h>


/*=======================================================================*/
/* Configuration */
#define SYS_TICK_PERIOD_IN_MS 100

#define ROT_ENC_DIR_PIN 23
#define ROT_ENC_CNT_PIN 15

void plu_setup(void)
{
	*(uint32_t *)0x40048084UL |= (1UL<<5);   /* Enable PLU Clock */
	*(uint32_t *)0x4004808CUL &= ~(1UL<<5);   /* Reset PLU */
	*(uint32_t *)0x4004808CUL |= (1UL<<5);   /* Clear Reset PLU */
	*(uint32_t *)0x40048080UL |= (1UL<<6);   /* Enable GPIO0 Clock */
	*(uint32_t *)0x40048088UL &= ~(1UL<<6);   /* Reset GPIO0 */
	*(uint32_t *)0x40048088UL |= (1UL<<6);   /* Clear Reset GPIO0 */
	*(uint32_t *)0x40048080UL |= (1UL<<7);   /* Enable SWM Clock */
	*(uint32_t *)0x40048088UL &= ~(1UL<<7);   /* Reset SWM */
	*(uint32_t *)0x40048088UL |= (1UL<<7);   /* Clear Reset SWM */
	*(uint32_t *)0x40048080UL |= (1UL<<18);   /* Enable IOCON Clock */
	*(uint32_t *)0x40048088UL &= ~(1UL<<18);   /* Reset IOCON */
	*(uint32_t *)0x40048088UL |= (1UL<<18);   /* Clear Reset IOCON */
	*(uint32_t *)0xA0002380UL |= (1UL<<1);    /* PIO0_1 GPIO DIRSETP: Setup as output */
	*(uint32_t *)0x4004402cUL &= ~(3UL<<3);    /* PIO0_1 IOCON: Clear mode, deactivate any pull-up/pulldown */
	*(uint32_t *)0x40044038UL &= ~(3UL<<3);    /* PIO0_8 IOCON: Clear mode */
	*(uint32_t *)0x40044038UL |= (2UL<<3);    /* PIO0_8 IOCON: Enable pull-up */
	*(uint32_t *)0xA0002400UL |= (1UL<<8);    /* PIO0_8 GPIO DIRCLRP: Setup as input */
	*(uint32_t *)0x40044034UL &= ~(3UL<<3);    /* PIO0_9 IOCON: Clear mode */
	*(uint32_t *)0x40044034UL |= (2UL<<3);    /* PIO0_9 IOCON: Enable pull-up */
	*(uint32_t *)0xA0002400UL |= (1UL<<9);    /* PIO0_9 GPIO DIRCLRP: Setup as input */
	*(uint32_t *)0xA0002380UL |= (1UL<<15);    /* PIO0_15 GPIO DIRSETP: Setup as output */
	*(uint32_t *)0x40044028UL &= ~(3UL<<3);    /* PIO0_15 IOCON: Clear mode, deactivate any pull-up/pulldown */
	*(uint32_t *)0x4004406cUL &= ~(3UL<<3);    /* PIO0_23 IOCON: Clear mode */
	*(uint32_t *)0x4004406cUL |= (2UL<<3);    /* PIO0_23 IOCON: Enable pull-up */
	*(uint32_t *)0xA0002400UL |= (1UL<<23);    /* PIO0_23 GPIO DIRCLRP: Setup as input */
	*(uint32_t *)0x4004405cUL &= ~(3UL<<3);    /* PIO0_30 IOCON: Clear mode */
	*(uint32_t *)0x4004405cUL |= (2UL<<3);    /* PIO0_30 IOCON: Enable pull-up */
	*(uint32_t *)0xA0002400UL |= (1UL<<30);    /* PIO0_30 GPIO DIRCLRP: Setup as input */
}

void plu_config(void)
{
 /* 
    Include the file, generated by NXP PLU Config Tool.
    Unfortunately some redefinitions are required
*/
#ifdef PLU 
#undef PLU
#endif
#define PLU (LPC_PLU0)
#define LUT LUT_MUX
#include "2x_rot_enc.c"
#undef PLU
#undef LUT
}

void plu_connect(void)
{
	/* PIO0_8 --> PLUINPUT0 */
	*(uint32_t *)0x4000c180 &= ~0x00000003UL; *(uint32_t *)0x4000c180 |= 0x00000001UL; /*SWM*/
	/* PIO0_9 --> PLUINPUT1 */
	*(uint32_t *)0x4000c180 &= ~0x0000000cUL; *(uint32_t *)0x4000c180 |= 0x00000004UL; /*SWM*/
	/* PLUOUT0 --> PIO0_23 */
	*(uint32_t *)0x4000c180 &= ~0x00003000UL; *(uint32_t *)0x4000c180 |= 0x00002000UL; /*SWM*/
	/* PLUOUT1 --> PIO0_15 */
	*(uint32_t *)0x4000c180 &= ~0x0000c000UL; *(uint32_t *)0x4000c180 |= 0x00004000UL; /*SWM*/
	/* LUT4 --> PLUOUT0 */
	*(uint32_t *)0x40028c00 = 0x00000004UL; /*PLU*/
	/* PLUINPUT0 --> LUT0_INP0 */
	*(uint32_t *)0x40028000 = 0x00000000UL; /*PLU*/
	/* PLUINPUT1 --> LUT0_INP1 */
	*(uint32_t *)0x40028004 = 0x00000001UL; /*PLU*/
	/* FF0 --> LUT0_INP2 */
	*(uint32_t *)0x40028008 = 0x00000020UL; /*PLU*/
	/* FF1 --> LUT0_INP3 */
	*(uint32_t *)0x4002800c = 0x00000021UL; /*PLU*/
	/* FF2 --> LUT0_INP4 */
	*(uint32_t *)0x40028010 = 0x00000022UL; /*PLU*/
	/* PLUINPUT0 --> LUT1_INP0 */
	*(uint32_t *)0x40028020 = 0x00000000UL; /*PLU*/
	/* PLUINPUT1 --> LUT1_INP1 */
	*(uint32_t *)0x40028024 = 0x00000001UL; /*PLU*/
	/* FF0 --> LUT1_INP2 */
	*(uint32_t *)0x40028028 = 0x00000020UL; /*PLU*/
	/* FF1 --> LUT1_INP3 */
	*(uint32_t *)0x4002802c = 0x00000021UL; /*PLU*/
	/* FF2 --> LUT1_INP4 */
	*(uint32_t *)0x40028030 = 0x00000022UL; /*PLU*/
	/* PLUINPUT0 --> LUT2_INP0 */
	*(uint32_t *)0x40028040 = 0x00000000UL; /*PLU*/
	/* PLUINPUT1 --> LUT2_INP1 */
	*(uint32_t *)0x40028044 = 0x00000001UL; /*PLU*/
	/* FF0 --> LUT2_INP2 */
	*(uint32_t *)0x40028048 = 0x00000020UL; /*PLU*/
	/* FF1 --> LUT2_INP3 */
	*(uint32_t *)0x4002804c = 0x00000021UL; /*PLU*/
	/* FF2 --> LUT2_INP4 */
	*(uint32_t *)0x40028050 = 0x00000022UL; /*PLU*/
	/* PLUINPUT0 --> LUT4_INP0 */
	*(uint32_t *)0x40028080 = 0x00000000UL; /*PLU*/
	/* PLUINPUT1 --> LUT4_INP1 */
	*(uint32_t *)0x40028084 = 0x00000001UL; /*PLU*/
	/* FF0 --> LUT4_INP2 */
	*(uint32_t *)0x40028088 = 0x00000020UL; /*PLU*/
	/* FF1 --> LUT4_INP3 */
	*(uint32_t *)0x4002808c = 0x00000021UL; /*PLU*/
	/* FF2 --> LUT4_INP4 */
	*(uint32_t *)0x40028090 = 0x00000022UL; /*PLU*/
	/* PLUINPUT0 --> LUT5_INP0 */
	*(uint32_t *)0x400280a0 = 0x00000000UL; /*PLU*/
	/* PLUINPUT1 --> LUT5_INP1 */
	*(uint32_t *)0x400280a4 = 0x00000001UL; /*PLU*/
	/* FF0 --> LUT5_INP2 */
	*(uint32_t *)0x400280a8 = 0x00000020UL; /*PLU*/
	/* FF2 --> LUT5_INP3 */
	*(uint32_t *)0x400280ac = 0x00000022UL; /*PLU*/
	/* LUT5 --> PLUOUT1 */
	*(uint32_t *)0x40028c04 = 0x00000005UL; /*PLU*/
	/* LUT0 --> FF0 */
	/* LUT1 --> FF1 */
	/* LUT2 --> FF2 */
	/* PIO0_30 --> PLU_CLKIN */
	*(uint32_t *)0x4000c01c &= ~0xff000000UL; *(uint32_t *)0x4000c01c |= 0x1e000000UL; /*SWM*/
	/* PIO0_23 --> LVLSHFT_IN0 */
	*(uint32_t *)0x4000c018 &= ~0x0000ff00UL; *(uint32_t *)0x4000c018 |= 0x00001700UL; /*SWM*/
	/* LVLSHFT_OUT0 --> PIO0_1 */
	*(uint32_t *)0x4000c018 &= ~0xff000000UL; *(uint32_t *)0x4000c018 |= 0x01000000UL; /*SWM*/
	/* CLKOUT --> PIO0_30 */
	*(uint32_t *)0x4000c014 &= ~0xff000000UL; *(uint32_t *)0x4000c014 |= 0x1e000000UL; /*SWM*/
	/* CLKOUT clock source select register: Select main clock */
	*(uint32_t *)0x400480F0UL = 1;  /*SYSCON CLKOUTSEL*/
	/* CLKOUT clock divider register: Divide by 2 */
	*(uint32_t *)0x400480F4UL = 2;  /*SYSCON CLKOUTDIV*/
}

/*=======================================================================*/
/* system procedures and sys tick master task */



volatile uint32_t sys_tick_irq_cnt=0;
volatile uint8_t rot_enc_value = 0;

void __attribute__ ((interrupt)) SysTick_Handler(void)
{  
  sys_tick_irq_cnt++;
  //GPIOSetBitValue(PORT0, 9, (sys_tick_irq_cnt & 1) == 0?0:1);
}

void __attribute__ ((interrupt)) PININT0_Handler(void)
{  
  LPC_PIN_INT->IST = 1;		// clear interrupt
  if ( LPC_GPIO_PORT->B0[ROT_ENC_DIR_PIN] )
  {
    if ( rot_enc_value < 255 )
    {
      rot_enc_value++;
    }
  }
  else
  {
    if ( rot_enc_value > 0 )
    {
      rot_enc_value--;
    }
  }
    
}



/*=======================================================================*/
static const unsigned char u8toa_tab[3]  = { 100, 10, 1 } ;
const char *u8toap(char * dest, uint8_t v)
{
  uint8_t pos;
  uint8_t d;
  uint8_t c;
  for( pos = 0; pos < 3; pos++ )
  {
      d = '0';
      c = *(u8toa_tab+pos);
      while( v >= c )
      {
	v -= c;
	d++;
      }
      dest[pos] = d;
  }  
  dest[3] = '\0';
  return dest;
}

/* v = value, d = number of digits */
const char *u8toa(uint8_t v, uint8_t d)
{
  static char buf[4];
  d = 3-d;
  return u8toap(buf, v) + d;
}



/*=======================================================================*/
/*
  setup the hardware and start interrupts.
  called by "Reset_Handler"
*/
int __attribute__ ((noinline)) main(void)
{
  int dir, tick;

  usart_t usart;
  uint8_t usart_rx_buf[32];
  

  /* call to the lpc lib setup procedure. This will set the IRC as clk src and main clk to 24 MHz */
  SystemInit(); 

  /* if the clock or PLL has been changed, also update the global variable SystemCoreClock */
  SystemCoreClockUpdate();

  /* set systick and start systick interrupt */
  SysTick_Config(main_clk/1000UL*(unsigned long)SYS_TICK_PERIOD_IN_MS);

  plu_setup();
  plu_config();
  plu_connect();
  
  GPIOInit();  
  Enable_Periph_Clock(CLK_IOCON);
  Enable_Periph_Clock(CLK_SWM);
  Enable_Periph_Clock(CLK_GPIO_INT);
  Do_Periph_Reset(CLK_GPIO_INT);
  
  LPC_SYSCON->PINTSEL0 = ROT_ENC_CNT_PIN;
  LPC_PIN_INT->ISEL = 0;		// edge sensitive
  LPC_PIN_INT->SIENR = 1;		// enable rising edge interrupt 
  LPC_PIN_INT->SIENF = 1;		// enable falling edge interrupt 
  NVIC_SetPriority(PININT0_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  NVIC_EnableIRQ(PININT0_IRQn);
  

  usart0_init(&usart, 5, /* tx */ 4, /* rx */ 0, usart_rx_buf, 32);  

  //GPIOSetDir( PORT0, 15, OUTPUT);
  //GPIOSetDir( PORT0, 23, INPUT);

  for(;;)
  {
    //GPIOSetBitValue(PORT0, 15, 1);
    //delay_micro_seconds(1000000);
    //GPIOSetBitValue(PORT0, 15, 0);
    delay_micro_seconds(1000000/2);

    dir = LPC_GPIO_PORT->B0[ROT_ENC_DIR_PIN];
    tick = GPIOGetPinValue( PORT0, ROT_ENC_CNT_PIN) == 0 ? 0 : 1;
    usart_write_string(&usart, "dir=");    
    usart_write_byte(&usart, '0'+dir);
    usart_write_string(&usart, " tick=");    
    usart_write_byte(&usart, '0'+tick);
    
    usart_write_string(&usart, " rot_enc_value=");    
    usart_write_string(&usart, u8toa(rot_enc_value,3));    

    usart_write_string(&usart, " rise=");    
    usart_write_string(&usart, u8toa(LPC_PIN_INT->RISE,3));    
    
    usart_write_string(&usart, " ist=");    
    usart_write_string(&usart, u8toa(LPC_PIN_INT->IST,3));    
    
    usart_write_string(&usart, " outputs=");    
    usart_write_byte(&usart, '0'+LPC_PLU0->OUTPUTS);
      
    
    
    usart_write_string(&usart, "\n"); 
    
    
  }
}

